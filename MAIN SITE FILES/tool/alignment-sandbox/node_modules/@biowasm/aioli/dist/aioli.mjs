const r = Symbol("Comlink.proxy"), K = Symbol("Comlink.endpoint"), C = Symbol("Comlink.releaseProxy"), p = Symbol("Comlink.thrown"), R = (l) => typeof l == "object" && l !== null || typeof l == "function", k = {
  canHandle: (l) => R(l) && l[r],
  serialize(l) {
    const { port1: c, port2: t } = new MessageChannel();
    return S(l, c), [t, [t]];
  },
  deserialize(l) {
    return l.start(), V(l);
  }
}, x = {
  canHandle: (l) => R(l) && p in l,
  serialize({ value: l }) {
    let c;
    return l instanceof Error ? c = {
      isError: !0,
      value: {
        message: l.message,
        name: l.name,
        stack: l.stack
      }
    } : c = { isError: !1, value: l }, [c, []];
  },
  deserialize(l) {
    throw l.isError ? Object.assign(new Error(l.value.message), l.value) : l.value;
  }
}, Y = /* @__PURE__ */ new Map([
  ["proxy", k],
  ["throw", x]
]);
function S(l, c = self) {
  c.addEventListener("message", function t(b) {
    if (!b || !b.data)
      return;
    const { id: d, type: e, path: Z } = Object.assign({ path: [] }, b.data), s = (b.data.argumentList || []).map(u);
    let n;
    try {
      const m = Z.slice(0, -1).reduce((i, W) => i[W], l), a = Z.reduce((i, W) => i[W], l);
      switch (e) {
        case "GET":
          n = a;
          break;
        case "SET":
          m[Z.slice(-1)[0]] = u(b.data.value), n = !0;
          break;
        case "APPLY":
          n = a.apply(m, s);
          break;
        case "CONSTRUCT":
          {
            const i = new a(...s);
            n = z(i);
          }
          break;
        case "ENDPOINT":
          {
            const { port1: i, port2: W } = new MessageChannel();
            S(l, W), n = U(i, [i]);
          }
          break;
        case "RELEASE":
          n = void 0;
          break;
        default:
          return;
      }
    } catch (m) {
      n = { value: m, [p]: 0 };
    }
    Promise.resolve(n).catch((m) => ({ value: m, [p]: 0 })).then((m) => {
      const [a, i] = X(m);
      c.postMessage(Object.assign(Object.assign({}, a), { id: d }), i), e === "RELEASE" && (c.removeEventListener("message", t), H(c));
    });
  }), c.start && c.start();
}
function N(l) {
  return l.constructor.name === "MessagePort";
}
function H(l) {
  N(l) && l.close();
}
function V(l, c) {
  return o(l, [], c);
}
function h(l) {
  if (l)
    throw new Error("Proxy has been released and is not useable");
}
function o(l, c = [], t = function() {
}) {
  let b = !1;
  const d = new Proxy(t, {
    get(e, Z) {
      if (h(b), Z === C)
        return () => G(l, {
          type: "RELEASE",
          path: c.map((s) => s.toString())
        }).then(() => {
          H(l), b = !0;
        });
      if (Z === "then") {
        if (c.length === 0)
          return { then: () => d };
        const s = G(l, {
          type: "GET",
          path: c.map((n) => n.toString())
        }).then(u);
        return s.then.bind(s);
      }
      return o(l, [...c, Z]);
    },
    set(e, Z, s) {
      h(b);
      const [n, m] = X(s);
      return G(l, {
        type: "SET",
        path: [...c, Z].map((a) => a.toString()),
        value: n
      }, m).then(u);
    },
    apply(e, Z, s) {
      h(b);
      const n = c[c.length - 1];
      if (n === K)
        return G(l, {
          type: "ENDPOINT"
        }).then(u);
      if (n === "bind")
        return o(l, c.slice(0, -1));
      const [m, a] = y(s);
      return G(l, {
        type: "APPLY",
        path: c.map((i) => i.toString()),
        argumentList: m
      }, a).then(u);
    },
    construct(e, Z) {
      h(b);
      const [s, n] = y(Z);
      return G(l, {
        type: "CONSTRUCT",
        path: c.map((m) => m.toString()),
        argumentList: s
      }, n).then(u);
    }
  });
  return d;
}
function J(l) {
  return Array.prototype.concat.apply([], l);
}
function y(l) {
  const c = l.map(X);
  return [c.map((t) => t[0]), J(c.map((t) => t[1]))];
}
const I = /* @__PURE__ */ new WeakMap();
function U(l, c) {
  return I.set(l, c), l;
}
function z(l) {
  return Object.assign(l, { [r]: !0 });
}
function X(l) {
  for (const [c, t] of Y)
    if (t.canHandle(l)) {
      const [b, d] = t.serialize(l);
      return [
        {
          type: "HANDLER",
          name: c,
          value: b
        },
        d
      ];
    }
  return [
    {
      type: "RAW",
      value: l
    },
    I.get(l) || []
  ];
}
function u(l) {
  switch (l.type) {
    case "HANDLER":
      return Y.get(l.name).deserialize(l.value);
    case "RAW":
      return l.value;
  }
}
function G(l, c, t) {
  return new Promise((b) => {
    const d = T();
    l.addEventListener("message", function e(Z) {
      !Z.data || !Z.data.id || Z.data.id !== d || (l.removeEventListener("message", e), b(Z.data));
    }), l.start && l.start(), l.postMessage(Object.assign({ id: d }, c), t);
  });
}
function T() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
const g = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0ICQ9U3ltYm9sKCJDb21saW5rLnByb3h5IiksQT1TeW1ib2woIkNvbWxpbmsuZW5kcG9pbnQiKSxSPVN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKSx5PVN5bWJvbCgiQ29tbGluay50aHJvd24iKSxfPWU9PnR5cGVvZiBlPT0ib2JqZWN0IiYmZSE9PW51bGx8fHR5cGVvZiBlPT0iZnVuY3Rpb24iLEw9e2NhbkhhbmRsZTplPT5fKGUpJiZlWyRdLHNlcmlhbGl6ZShlKXtjb25zdHtwb3J0MTpyLHBvcnQyOml9PW5ldyBNZXNzYWdlQ2hhbm5lbDtyZXR1cm4gYihlLHIpLFtpLFtpXV19LGRlc2VyaWFsaXplKGUpe3JldHVybiBlLnN0YXJ0KCksQyhlKX19LE89e2NhbkhhbmRsZTplPT5fKGUpJiZ5IGluIGUsc2VyaWFsaXplKHt2YWx1ZTplfSl7bGV0IHI7cmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvcj9yPXtpc0Vycm9yOiEwLHZhbHVlOnttZXNzYWdlOmUubWVzc2FnZSxuYW1lOmUubmFtZSxzdGFjazplLnN0YWNrfX06cj17aXNFcnJvcjohMSx2YWx1ZTplfSxbcixbXV19LGRlc2VyaWFsaXplKGUpe3Rocm93IGUuaXNFcnJvcj9PYmplY3QuYXNzaWduKG5ldyBFcnJvcihlLnZhbHVlLm1lc3NhZ2UpLGUudmFsdWUpOmUudmFsdWV9fSxFPW5ldyBNYXAoW1sicHJveHkiLExdLFsidGhyb3ciLE9dXSk7ZnVuY3Rpb24gYihlLHI9c2VsZil7ci5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmdW5jdGlvbiBpKHMpe2lmKCFzfHwhcy5kYXRhKXJldHVybjtjb25zdHtpZDpvLHR5cGU6YSxwYXRoOm59PU9iamVjdC5hc3NpZ24oe3BhdGg6W119LHMuZGF0YSksdT0ocy5kYXRhLmFyZ3VtZW50TGlzdHx8W10pLm1hcChtKTtsZXQgbDt0cnl7Y29uc3QgYz1uLnNsaWNlKDAsLTEpLnJlZHVjZSgoZCxoKT0+ZFtoXSxlKSxmPW4ucmVkdWNlKChkLGgpPT5kW2hdLGUpO3N3aXRjaChhKXtjYXNlIkdFVCI6bD1mO2JyZWFrO2Nhc2UiU0VUIjpjW24uc2xpY2UoLTEpWzBdXT1tKHMuZGF0YS52YWx1ZSksbD0hMDticmVhaztjYXNlIkFQUExZIjpsPWYuYXBwbHkoYyx1KTticmVhaztjYXNlIkNPTlNUUlVDVCI6e2NvbnN0IGQ9bmV3IGYoLi4udSk7bD16KGQpfWJyZWFrO2Nhc2UiRU5EUE9JTlQiOntjb25zdHtwb3J0MTpkLHBvcnQyOmh9PW5ldyBNZXNzYWdlQ2hhbm5lbDtiKGUsaCksbD1OKGQsW2RdKX1icmVhaztjYXNlIlJFTEVBU0UiOmw9dm9pZCAwO2JyZWFrO2RlZmF1bHQ6cmV0dXJufX1jYXRjaChjKXtsPXt2YWx1ZTpjLFt5XTowfX1Qcm9taXNlLnJlc29sdmUobCkuY2F0Y2goYz0+KHt2YWx1ZTpjLFt5XTowfSkpLnRoZW4oYz0+e2NvbnN0W2YsZF09UyhjKTtyLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxmKSx7aWQ6b30pLGQpLGE9PT0iUkVMRUFTRSImJihyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGkpLE0ocikpfSl9KSxyLnN0YXJ0JiZyLnN0YXJ0KCl9ZnVuY3Rpb24gVChlKXtyZXR1cm4gZS5jb25zdHJ1Y3Rvci5uYW1lPT09Ik1lc3NhZ2VQb3J0In1mdW5jdGlvbiBNKGUpe1QoZSkmJmUuY2xvc2UoKX1mdW5jdGlvbiBDKGUscil7cmV0dXJuIHcoZSxbXSxyKX1mdW5jdGlvbiBwKGUpe2lmKGUpdGhyb3cgbmV3IEVycm9yKCJQcm94eSBoYXMgYmVlbiByZWxlYXNlZCBhbmQgaXMgbm90IHVzZWFibGUiKX1mdW5jdGlvbiB3KGUscj1bXSxpPWZ1bmN0aW9uKCl7fSl7bGV0IHM9ITE7Y29uc3Qgbz1uZXcgUHJveHkoaSx7Z2V0KGEsbil7aWYocChzKSxuPT09UilyZXR1cm4oKT0+ZyhlLHt0eXBlOiJSRUxFQVNFIixwYXRoOnIubWFwKHU9PnUudG9TdHJpbmcoKSl9KS50aGVuKCgpPT57TShlKSxzPSEwfSk7aWYobj09PSJ0aGVuIil7aWYoci5sZW5ndGg9PT0wKXJldHVybnt0aGVuOigpPT5vfTtjb25zdCB1PWcoZSx7dHlwZToiR0VUIixwYXRoOnIubWFwKGw9PmwudG9TdHJpbmcoKSl9KS50aGVuKG0pO3JldHVybiB1LnRoZW4uYmluZCh1KX1yZXR1cm4gdyhlLFsuLi5yLG5dKX0sc2V0KGEsbix1KXtwKHMpO2NvbnN0W2wsY109Uyh1KTtyZXR1cm4gZyhlLHt0eXBlOiJTRVQiLHBhdGg6Wy4uLnIsbl0ubWFwKGY9PmYudG9TdHJpbmcoKSksdmFsdWU6bH0sYykudGhlbihtKX0sYXBwbHkoYSxuLHUpe3Aocyk7Y29uc3QgbD1yW3IubGVuZ3RoLTFdO2lmKGw9PT1BKXJldHVybiBnKGUse3R5cGU6IkVORFBPSU5UIn0pLnRoZW4obSk7aWYobD09PSJiaW5kIilyZXR1cm4gdyhlLHIuc2xpY2UoMCwtMSkpO2NvbnN0W2MsZl09UCh1KTtyZXR1cm4gZyhlLHt0eXBlOiJBUFBMWSIscGF0aDpyLm1hcChkPT5kLnRvU3RyaW5nKCkpLGFyZ3VtZW50TGlzdDpjfSxmKS50aGVuKG0pfSxjb25zdHJ1Y3QoYSxuKXtwKHMpO2NvbnN0W3UsbF09UChuKTtyZXR1cm4gZyhlLHt0eXBlOiJDT05TVFJVQ1QiLHBhdGg6ci5tYXAoYz0+Yy50b1N0cmluZygpKSxhcmd1bWVudExpc3Q6dX0sbCkudGhlbihtKX19KTtyZXR1cm4gb31mdW5jdGlvbiBEKGUpe3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLGUpfWZ1bmN0aW9uIFAoZSl7Y29uc3Qgcj1lLm1hcChTKTtyZXR1cm5bci5tYXAoaT0+aVswXSksRChyLm1hcChpPT5pWzFdKSldfWNvbnN0IEY9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gTihlLHIpe3JldHVybiBGLnNldChlLHIpLGV9ZnVuY3Rpb24geihlKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHtbJF06ITB9KX1mdW5jdGlvbiBTKGUpe2Zvcihjb25zdFtyLGldb2YgRSlpZihpLmNhbkhhbmRsZShlKSl7Y29uc3RbcyxvXT1pLnNlcmlhbGl6ZShlKTtyZXR1cm5be3R5cGU6IkhBTkRMRVIiLG5hbWU6cix2YWx1ZTpzfSxvXX1yZXR1cm5be3R5cGU6IlJBVyIsdmFsdWU6ZX0sRi5nZXQoZSl8fFtdXX1mdW5jdGlvbiBtKGUpe3N3aXRjaChlLnR5cGUpe2Nhc2UiSEFORExFUiI6cmV0dXJuIEUuZ2V0KGUubmFtZSkuZGVzZXJpYWxpemUoZS52YWx1ZSk7Y2FzZSJSQVciOnJldHVybiBlLnZhbHVlfX1mdW5jdGlvbiBnKGUscixpKXtyZXR1cm4gbmV3IFByb21pc2Uocz0+e2NvbnN0IG89VygpO2UuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsZnVuY3Rpb24gYShuKXshbi5kYXRhfHwhbi5kYXRhLmlkfHxuLmRhdGEuaWQhPT1vfHwoZS5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIixhKSxzKG4uZGF0YSkpfSksZS5zdGFydCYmZS5zdGFydCgpLGUucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7aWQ6b30sciksaSl9KX1mdW5jdGlvbiBXKCl7cmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKT0+TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpLmpvaW4oIi0iKX1jb25zdCBqPWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDUsMSw5NiwwLDEsMTIzLDMsMiwxLDAsMTAsMTAsMSw4LDAsNjUsMCwyNTMsMTUsMjUzLDk4LDExXSkpLHg9ImVhZ2VyIixrPSJsYXp5IixJPXtzc3c6WyJzaW1kIl0sbWluaW1hcDI6WyJzaW1kIl19LHQ9e3Rvb2xzOltdLGNvbmZpZzp7fSxmaWxlczpbXSxiYXNlOnt9LGZzOnt9LGFzeW5jIGluaXQoKXtpZih0LnRvb2xzLmxlbmd0aD09PTApdGhyb3ciRXhwZWN0aW5nIGF0IGxlYXN0IDEgdG9vbC4iO2lmKHQuYmFzZT10LnRvb2xzLmZpbmQoZT0+ZS5yZWluaXQhPT0hMCksIXQuYmFzZSl0aHJvdyJDb3VsZCBub3QgZmluZCBhIHRvb2wgd2l0aCBgcmVpbml0OiBmYWxzZWAgdG8gdXNlIGFzIHRoZSBiYXNlIG1vZHVsZS4gVG8gZml4IHRoaXMgaXNzdWUsIGluY2x1ZGUgdGhlIHRvb2wgYGJhc2UvMS4wLjBgIHdoZW4gaW5pdGlhbGl6aW5nIEFpb2xpLiI7cmV0dXJuIHQuYmFzZS5pc0Jhc2VNb2R1bGU9ITAsYXdhaXQgdGhpcy5fc2V0dXAodC5iYXNlKSxhd2FpdCB0aGlzLl9pbml0TW9kdWxlcygpLHQuX2xvZygiUmVhZHkiKSwhMH0sYXN5bmMgX2luaXRNb2R1bGVzKCl7YXdhaXQgUHJvbWlzZS5hbGwodC50b29scy5tYXAodGhpcy5fc2V0dXApKSxhd2FpdCB0aGlzLl9zZXR1cEZTKCl9LG1vdW50KGU9W10pe2NvbnN0IHI9YCR7dC5jb25maWcuZGlyU2hhcmVkfSR7dC5jb25maWcuZGlyRGF0YX1gLGk9YCR7dC5jb25maWcuZGlyU2hhcmVkfSR7dC5jb25maWcuZGlyTW91bnRlZH1gO2xldCBzPVtdLG89W10sYT1bXTshQXJyYXkuaXNBcnJheShlKSYmIShlIGluc3RhbmNlb2YgRmlsZUxpc3QpJiYoZT1bZV0pLHQuX2xvZyhgTW91bnRpbmcgJHtlLmxlbmd0aH0gZmlsZXNgKTtmb3IobGV0IG4gb2YgZSl7aWYobiBpbnN0YW5jZW9mIEZpbGV8fChuPT1udWxsP3ZvaWQgMDpuLmRhdGEpaW5zdGFuY2VvZiBCbG9iJiZuLm5hbWV8fHR5cGVvZihuPT1udWxsP3ZvaWQgMDpuLmRhdGEpPT0ic3RyaW5nIiYmbi5uYW1lKXR5cGVvZihuPT1udWxsP3ZvaWQgMDpuLmRhdGEpPT0ic3RyaW5nIiYmKG4uZGF0YT1uZXcgQmxvYihbbi5kYXRhXSx7dHlwZToidGV4dC9wbGFpbiJ9KSkscy5wdXNoKG4pLGEucHVzaChuLm5hbWUpO2Vsc2UgaWYobi5uYW1lJiZuLnVybClvLnB1c2gobik7ZWxzZSBpZih0eXBlb2Ygbj09InN0cmluZyImJm4uc3RhcnRzV2l0aCgiaHR0cCIpKW49e3VybDpuLG5hbWU6bi5zcGxpdCgiLy8iKS5wb3AoKS5yZXBsYWNlKC9cLy9nLCItIil9LG8ucHVzaChuKTtlbHNlIHRocm93J0Nhbm5vdCBtb3VudCBmaWxlKHMpIHNwZWNpZmllZC4gTXVzdCBiZSBhIEZpbGUsIEJsb2IsIGEgVVJMIHN0cmluZywgb3IgeyBuYW1lOiAiZmlsZS50eHQiLCBkYXRhOiAic3RyaW5nIiB9Lic7YS5wdXNoKG4ubmFtZSl9dHJ5e3QuZnMudW5tb3VudChpKX1jYXRjaHt9Zm9yKGxldCBuIG9mIG8pdC5mcy5jcmVhdGVMYXp5RmlsZShyLG4ubmFtZSxuLnVybCwhMCwhMCk7cmV0dXJuIHQuZmlsZXM9dC5maWxlcy5jb25jYXQocyksdC5iYXNlLm1vZHVsZS5GUy5tb3VudCh0LmJhc2UubW9kdWxlLldPUktFUkZTLHtmaWxlczp0LmZpbGVzLmZpbHRlcihuPT5uIGluc3RhbmNlb2YgRmlsZSksYmxvYnM6dC5maWxlcy5maWx0ZXIobj0+KG49PW51bGw/dm9pZCAwOm4uZGF0YSlpbnN0YW5jZW9mIEJsb2IpfSxpKSxzLm1hcChuPT57Y29uc3QgdT1gJHtpfS8ke24ubmFtZX1gLGw9YCR7cn0vJHtuLm5hbWV9YDt0cnl7dC5mcy51bmxpbmsobCl9Y2F0Y2h7fXQuX2xvZyhgQ3JlYXRpbmcgc3ltbGluazogJHtsfSAtLT4gJHt1fWApLHQuZnMuc3ltbGluayh1LGwpfSksYS5tYXAobj0+YCR7cn0vJHtufWApfSxhc3luYyBleGVjKGUscj1udWxsKXtpZih0Ll9sb2coYEV4ZWN1dGluZyAlYyR7ZX0lYyBhcmdzPSR7cn1gLCJjb2xvcjpkYXJrYmx1ZTsgZm9udC13ZWlnaHQ6Ym9sZCIsIiIpLCFlKXRocm93IkV4cGVjdGluZyBhIGNvbW1hbmQiO2xldCBpPWU7cj09bnVsbCYmKHI9ZS5zcGxpdCgiICIpLGk9ci5zaGlmdCgpKTtjb25zdCBzPXQudG9vbHMuZmluZChhPT57dmFyIHU7bGV0IG49aTtyZXR1cm4oKHU9YT09bnVsbD92b2lkIDA6YS5mZWF0dXJlcyk9PW51bGw/dm9pZCAwOnUuc2ltZCk9PT0hMCYmKG49YCR7bn0tc2ltZGApLGEucHJvZ3JhbT09bn0pO2lmKHM9PW51bGwpdGhyb3dgUHJvZ3JhbSAke2l9IG5vdCBmb3VuZC5gO3Muc3Rkb3V0PSIiLHMuc3RkZXJyPSIiLHMubG9hZGluZz09ayYmKHMubG9hZGluZz14LGF3YWl0IHRoaXMuX2luaXRNb2R1bGVzKCkpO3RyeXtzLm1vZHVsZS5jYWxsTWFpbihyKX1jYXRjaChhKXtjb25zb2xlLmVycm9yKGEpfXRyeXtzLm1vZHVsZS5GUy5jbG9zZShzLm1vZHVsZS5GUy5zdHJlYW1zWzFdKSxzLm1vZHVsZS5GUy5jbG9zZShzLm1vZHVsZS5GUy5zdHJlYW1zWzJdKX1jYXRjaHt9cy5tb2R1bGUuRlMuc3RyZWFtc1sxXT1zLm1vZHVsZS5GUy5vcGVuKCIvZGV2L3N0ZG91dCIsInciKSxzLm1vZHVsZS5GUy5zdHJlYW1zWzJdPXMubW9kdWxlLkZTLm9wZW4oIi9kZXYvc3RkZXJyIiwidyIpO2xldCBvPXtzdGRvdXQ6cy5zdGRvdXQsc3RkZXJyOnMuc3RkZXJyfTtpZih0LmNvbmZpZy5wcmludEludGVybGVhdmVkJiYobz1zLnN0ZG91dCkscy5yZWluaXQ9PT0hMCl7Y29uc3QgYT10LmJhc2UubW9kdWxlLkZTLmN3ZCgpO09iamVjdC5hc3NpZ24ocyxzLmNvbmZpZykscy5yZWFkeT0hMSxhd2FpdCB0aGlzLmluaXQoKSxzLmlzQmFzZU1vZHVsZSYmdGhpcy5tb3VudCgpLHRoaXMuY2QoYSl9cmV0dXJuIG99LGNhdChlKXtyZXR1cm4gdC5fZmlsZW9wKCJjYXQiLGUpfSxscyhlKXtyZXR1cm4gdC5fZmlsZW9wKCJscyIsZSl9LGRvd25sb2FkKGUpe3JldHVybiB0Ll9maWxlb3AoImRvd25sb2FkIixlKX0scHdkKCl7cmV0dXJuIHQuZnMuY3dkKCl9LGNkKGUpe2ZvcihsZXQgciBvZiB0LnRvb2xzKSFyLm1vZHVsZXx8ci5tb2R1bGUuRlMuY2hkaXIoZSl9LG1rZGlyKGUpe3JldHVybiB0LmZzLm1rZGlyKGUpLCEwfSxfc3RkaW5UeHQ6IiIsX3N0ZGluUHRyOjAsZ2V0IHN0ZGluKCl7cmV0dXJuIHQuX3N0ZGluVHh0fSxzZXQgc3RkaW4oZT0iIil7dC5fbG9nKGBTZXR0aW5nIHN0ZGluIHRvICVjJHtlfSVjYCwiY29sb3I6ZGFya2JsdWUiLCIiKSx0Ll9zdGRpblR4dD1lLHQuX3N0ZGluUHRyPTB9LGFzeW5jIF9zZXR1cChlKXtpZihlLnJlYWR5KXJldHVybjtpZih0Ll9sb2coYFNldHRpbmcgdXAgJHtlLnRvb2x9IChiYXNlID0gJHtlLmlzQmFzZU1vZHVsZT09PSEwfSkuLi5gKSxlLmNvbmZpZz1PYmplY3QuYXNzaWduKHt9LGUpLGUudXJsUHJlZml4fHwoZS51cmxQcmVmaXg9YCR7dC5jb25maWcudXJsQ0ROfS8ke2UudG9vbH0vJHtlLnZlcnNpb259YCksZS5wcm9ncmFtfHwoZS5wcm9ncmFtPWUudG9vbCksZS5mZWF0dXJlc3x8KGUuZmVhdHVyZXM9e30sKElbZS5wcm9ncmFtXXx8W10pLmluY2x1ZGVzKCJzaW1kIikmJihhd2FpdCBqKCk/KGUucHJvZ3JhbSs9Ii1zaW1kIixlLmZlYXR1cmVzLnNpbWQ9ITApOnQuX2xvZyhgV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlcjsgd2lsbCBsb2FkIG5vbi1TSU1EIHZlcnNpb24gb2YgJHtlLnByb2dyYW19LmApKSksZS5pc0Jhc2VNb2R1bGUmJihlLmxvYWRpbmc9eCksZS5sb2FkaW5nPT09ayl7dC5fbG9nKGBXaWxsIGxhenktbG9hZCAke2UudG9vbH07IHNraXBwaW5nIGluaXRpYWxpemF0aW9uLmApO3JldHVybn1zZWxmLmltcG9ydFNjcmlwdHMoYCR7ZS51cmxQcmVmaXh9LyR7ZS5wcm9ncmFtfS5qc2ApLGUubW9kdWxlPWF3YWl0IE1vZHVsZSh7dGhpc1Byb2dyYW06ZS5wcm9ncmFtLGxvY2F0ZUZpbGU6KGkscyk9PmAke2UudXJsUHJlZml4fS8ke2l9YCxzdGRpbjooKT0+dC5fc3RkaW5QdHI8dC5zdGRpbi5sZW5ndGg/dC5zdGRpbi5jaGFyQ29kZUF0KHQuX3N0ZGluUHRyKyspOih0LnN0ZGluPSIiLG51bGwpLHByaW50Omk9PmUuc3Rkb3V0Kz1gJHtpfQpgLHByaW50RXJyOnQuY29uZmlnLnByaW50SW50ZXJsZWF2ZWQ/aT0+ZS5zdGRvdXQrPWAke2l9CmA6aT0+ZS5zdGRlcnIrPWAke2l9CmB9KTtjb25zdCByPWUubW9kdWxlLkZTO2UuaXNCYXNlTW9kdWxlPyh0Ll9sb2coYFNldHRpbmcgdXAgJHtlLnRvb2x9IHdpdGggYmFzZSBtb2R1bGUgZmlsZXN5c3RlbS4uLmApLHIubWtkaXIodC5jb25maWcuZGlyU2hhcmVkLDUxMSksci5ta2RpcihgJHt0LmNvbmZpZy5kaXJTaGFyZWR9LyR7dC5jb25maWcuZGlyRGF0YX1gLDUxMSksci5ta2RpcihgJHt0LmNvbmZpZy5kaXJTaGFyZWR9LyR7dC5jb25maWcuZGlyTW91bnRlZH1gLDUxMSksci5jaGRpcihgJHt0LmNvbmZpZy5kaXJTaGFyZWR9LyR7dC5jb25maWcuZGlyRGF0YX1gKSx0LmZzPXIpOih0Ll9sb2coYFNldHRpbmcgdXAgJHtlLnRvb2x9IHdpdGggZmlsZXN5c3RlbS4uLmApLHIubWtkaXIodC5jb25maWcuZGlyU2hhcmVkKSxyLm1vdW50KGUubW9kdWxlLlBST1hZRlMse3Jvb3Q6dC5jb25maWcuZGlyU2hhcmVkLGZzOnQuZnN9LHQuY29uZmlnLmRpclNoYXJlZCksci5jaGRpcih0LmZzLmN3ZCgpKSksZS5zdGRvdXQ9IiIsZS5zdGRlcnI9IiIsZS5yZWFkeT0hMH0sYXN5bmMgX3NldHVwRlMoKXtjb25zdCBlPXQuZnM7Zm9yKGxldCByIG9mIHQudG9vbHMpe2lmKCFyLnJlYWR5KWNvbnRpbnVlO2NvbnN0IGk9ci5tb2R1bGUuRlMscz1gLyR7ci50b29sfWAsbz1gJHt0LmNvbmZpZy5kaXJTaGFyZWR9JHtzfWA7IWkuYW5hbHl6ZVBhdGgocykuZXhpc3RzfHxlLmFuYWx5emVQYXRoKG8pLmV4aXN0c3x8KHQuX2xvZyhgTW91bnRpbmcgJHtzfSBvbnRvICR7dC5iYXNlLnRvb2x9IGZpbGVzeXN0ZW0gYXQgJHtvfWApLGUubWtkaXIobyksZS5tb3VudCh0LmJhc2UubW9kdWxlLlBST1hZRlMse3Jvb3Q6cyxmczppfSxvKSl9fSxfZmlsZW9wKGUscil7dC5fbG9nKGBSdW5uaW5nICR7ZX0gJHtyfWApO2NvbnN0IGk9dC5mcy5hbmFseXplUGF0aChyKTtpZighaS5leGlzdHMpcmV0dXJuIHQuX2xvZyhgRmlsZSAke3J9IG5vdCBmb3VuZC5gKSwhMTtzd2l0Y2goZSl7Y2FzZSJjYXQiOnJldHVybiB0LmZzLnJlYWRGaWxlKHIse2VuY29kaW5nOiJ1dGY4In0pO2Nhc2UibHMiOnJldHVybiB0LmZzLmlzRmlsZShpLm9iamVjdC5tb2RlKT90LmZzLnN0YXQocik6dC5mcy5yZWFkZGlyKHIpO2Nhc2UiZG93bmxvYWQiOmNvbnN0IHM9bmV3IEJsb2IoW3RoaXMuY2F0KHIpXSk7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwocyl9cmV0dXJuITF9LF9sb2coZSl7aWYoIXQuY29uZmlnLmRlYnVnKXJldHVybjtsZXQgcj1bLi4uYXJndW1lbnRzXTtyLnNoaWZ0KCksY29uc29sZS5sb2coYCVjW1dlYldvcmtlcl0lYyAke2V9YCwiZm9udC13ZWlnaHQ6Ym9sZCIsIiIsLi4ucil9fTtiKHQpfSkoKTsK", L = typeof window < "u" && window.Blob && new Blob([atob(g)], { type: "text/javascript;charset=utf-8" });
function F() {
  const l = L && (window.URL || window.webkitURL).createObjectURL(L);
  try {
    return l ? new Worker(l) : new Worker("data:application/javascript;base64," + g);
  } finally {
    l && (window.URL || window.webkitURL).revokeObjectURL(l);
  }
}
const v = "https://biowasm.com/cdn/v3", f = "https://stg.biowasm.com/cdn/v3", w = {
  urlCDN: v,
  urlCDNStg: f,
  dirShared: "/shared",
  dirMounted: "/mnt",
  dirData: "/data",
  printInterleaved: !0,
  callback: null,
  debug: !1,
  env: "prd"
};
class j {
  constructor(c, t = {}) {
    if (c == null)
      throw "Expecting array of tools as input to Aioli constructor.";
    return Array.isArray(c) || (c = [c]), t = Object.assign({}, w, t), c = c.map(this._parseTool), t.env === "stg" && (t.urlCDN = t.urlCDNStg), this.tools = c, this.config = t, this.config.callback != null && (this.callback = this.config.callback), delete this.config.callback, this.init();
  }
  async init() {
    const c = new F();
    this.callback && (c.onmessage = (b) => {
      b.data.type === "biowasm" && this.callback(b.data.value);
    });
    const t = V(c);
    return t.tools = this.tools, t.config = this.config, await t.init(), t;
  }
  _parseTool(c) {
    if (typeof c != "string")
      return c;
    const t = c.split("/");
    if (t.length != 2 && t.length != 3)
      throw "Expecting '<tool>/<version>' or '<tool>/<program>/<version>'";
    return {
      tool: t[0],
      program: t.length == 3 ? t[1] : t[0],
      version: t[t.length - 1]
    };
  }
}
export {
  j as default
};
